// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef PROTOBUF_msg_2eproto__INCLUDED
#define PROTOBUF_msg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace schedulerMessages {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_msg_2eproto();
void protobuf_AssignDesc_msg_2eproto();
void protobuf_ShutdownFile_msg_2eproto();

class Msg;
class Request;
class Request_add_dependency;
class Request_assign;
class Request_cancel;
class Request_finish;
class Request_queue;
class Request_receive;
class Request_requeue;
class Response;
class Response_add_dependency;
class Response_assign;
class Response_cancel;
class Response_finish;
class Response_queue;
class Response_receive;
class Response_requeue;

// ===================================================================

class Msg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Msg) */ {
 public:
  Msg();
  virtual ~Msg();

  Msg(const Msg& from);

  inline Msg& operator=(const Msg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg& default_instance();

  enum TypeCase {
    kREQUEST = 1,
    kRESPONSE = 2,
    TYPE_NOT_SET = 0,
  };

  void Swap(Msg* other);

  // implements Message ----------------------------------------------

  inline Msg* New() const { return New(NULL); }

  Msg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg& from);
  void MergeFrom(const Msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Msg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .schedulerMessages.Request REQUEST = 1;
  bool has_request() const;
  void clear_request();
  static const int kREQUESTFieldNumber = 1;
  const ::schedulerMessages::Request& request() const;
  ::schedulerMessages::Request* mutable_request();
  ::schedulerMessages::Request* release_request();
  void set_allocated_request(::schedulerMessages::Request* request);

  // optional .schedulerMessages.Response RESPONSE = 2;
  bool has_response() const;
  void clear_response();
  static const int kRESPONSEFieldNumber = 2;
  const ::schedulerMessages::Response& response() const;
  ::schedulerMessages::Response* mutable_response();
  ::schedulerMessages::Response* release_response();
  void set_allocated_response(::schedulerMessages::Response* response);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:schedulerMessages.Msg)
 private:
  inline void set_has_request();
  inline void set_has_response();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union TypeUnion {
    TypeUnion() {}
    ::schedulerMessages::Request* request_;
    ::schedulerMessages::Response* response_;
  } type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Msg* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum TypeCase {
    kASSIGN = 1,
    kQUEUE = 2,
    kRECEIVE = 3,
    kREQUEUE = 4,
    kFINISH = 5,
    kCANCEL = 6,
    kADDDEPENDENCY = 7,
    TYPE_NOT_SET = 0,
  };

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  inline Request* New() const { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .schedulerMessages.Request_assign ASSIGN = 1;
  bool has_assign() const;
  void clear_assign();
  static const int kASSIGNFieldNumber = 1;
  const ::schedulerMessages::Request_assign& assign() const;
  ::schedulerMessages::Request_assign* mutable_assign();
  ::schedulerMessages::Request_assign* release_assign();
  void set_allocated_assign(::schedulerMessages::Request_assign* assign);

  // optional .schedulerMessages.Request_queue QUEUE = 2;
  bool has_queue() const;
  void clear_queue();
  static const int kQUEUEFieldNumber = 2;
  const ::schedulerMessages::Request_queue& queue() const;
  ::schedulerMessages::Request_queue* mutable_queue();
  ::schedulerMessages::Request_queue* release_queue();
  void set_allocated_queue(::schedulerMessages::Request_queue* queue);

  // optional .schedulerMessages.Request_receive RECEIVE = 3;
  bool has_receive() const;
  void clear_receive();
  static const int kRECEIVEFieldNumber = 3;
  const ::schedulerMessages::Request_receive& receive() const;
  ::schedulerMessages::Request_receive* mutable_receive();
  ::schedulerMessages::Request_receive* release_receive();
  void set_allocated_receive(::schedulerMessages::Request_receive* receive);

  // optional .schedulerMessages.Request_requeue REQUEUE = 4;
  bool has_requeue() const;
  void clear_requeue();
  static const int kREQUEUEFieldNumber = 4;
  const ::schedulerMessages::Request_requeue& requeue() const;
  ::schedulerMessages::Request_requeue* mutable_requeue();
  ::schedulerMessages::Request_requeue* release_requeue();
  void set_allocated_requeue(::schedulerMessages::Request_requeue* requeue);

  // optional .schedulerMessages.Request_finish FINISH = 5;
  bool has_finish() const;
  void clear_finish();
  static const int kFINISHFieldNumber = 5;
  const ::schedulerMessages::Request_finish& finish() const;
  ::schedulerMessages::Request_finish* mutable_finish();
  ::schedulerMessages::Request_finish* release_finish();
  void set_allocated_finish(::schedulerMessages::Request_finish* finish);

  // optional .schedulerMessages.Request_cancel CANCEL = 6;
  bool has_cancel() const;
  void clear_cancel();
  static const int kCANCELFieldNumber = 6;
  const ::schedulerMessages::Request_cancel& cancel() const;
  ::schedulerMessages::Request_cancel* mutable_cancel();
  ::schedulerMessages::Request_cancel* release_cancel();
  void set_allocated_cancel(::schedulerMessages::Request_cancel* cancel);

  // optional .schedulerMessages.Request_add_dependency ADD_DEPENDENCY = 7;
  bool has_add_dependency() const;
  void clear_add_dependency();
  static const int kADDDEPENDENCYFieldNumber = 7;
  const ::schedulerMessages::Request_add_dependency& add_dependency() const;
  ::schedulerMessages::Request_add_dependency* mutable_add_dependency();
  ::schedulerMessages::Request_add_dependency* release_add_dependency();
  void set_allocated_add_dependency(::schedulerMessages::Request_add_dependency* add_dependency);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:schedulerMessages.Request)
 private:
  inline void set_has_assign();
  inline void set_has_queue();
  inline void set_has_receive();
  inline void set_has_requeue();
  inline void set_has_finish();
  inline void set_has_cancel();
  inline void set_has_add_dependency();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union TypeUnion {
    TypeUnion() {}
    ::schedulerMessages::Request_assign* assign_;
    ::schedulerMessages::Request_queue* queue_;
    ::schedulerMessages::Request_receive* receive_;
    ::schedulerMessages::Request_requeue* requeue_;
    ::schedulerMessages::Request_finish* finish_;
    ::schedulerMessages::Request_cancel* cancel_;
    ::schedulerMessages::Request_add_dependency* add_dependency_;
  } type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum TypeCase {
    kASSIGN = 1,
    kQUEUE = 2,
    kRECEIVE = 3,
    kREQUEUE = 4,
    kFINISH = 5,
    kCANCEL = 6,
    kADDDEPENDENCY = 7,
    TYPE_NOT_SET = 0,
  };

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .schedulerMessages.Response_assign ASSIGN = 1;
  bool has_assign() const;
  void clear_assign();
  static const int kASSIGNFieldNumber = 1;
  const ::schedulerMessages::Response_assign& assign() const;
  ::schedulerMessages::Response_assign* mutable_assign();
  ::schedulerMessages::Response_assign* release_assign();
  void set_allocated_assign(::schedulerMessages::Response_assign* assign);

  // optional .schedulerMessages.Response_queue QUEUE = 2;
  bool has_queue() const;
  void clear_queue();
  static const int kQUEUEFieldNumber = 2;
  const ::schedulerMessages::Response_queue& queue() const;
  ::schedulerMessages::Response_queue* mutable_queue();
  ::schedulerMessages::Response_queue* release_queue();
  void set_allocated_queue(::schedulerMessages::Response_queue* queue);

  // optional .schedulerMessages.Response_receive RECEIVE = 3;
  bool has_receive() const;
  void clear_receive();
  static const int kRECEIVEFieldNumber = 3;
  const ::schedulerMessages::Response_receive& receive() const;
  ::schedulerMessages::Response_receive* mutable_receive();
  ::schedulerMessages::Response_receive* release_receive();
  void set_allocated_receive(::schedulerMessages::Response_receive* receive);

  // optional .schedulerMessages.Response_requeue REQUEUE = 4;
  bool has_requeue() const;
  void clear_requeue();
  static const int kREQUEUEFieldNumber = 4;
  const ::schedulerMessages::Response_requeue& requeue() const;
  ::schedulerMessages::Response_requeue* mutable_requeue();
  ::schedulerMessages::Response_requeue* release_requeue();
  void set_allocated_requeue(::schedulerMessages::Response_requeue* requeue);

  // optional .schedulerMessages.Response_finish FINISH = 5;
  bool has_finish() const;
  void clear_finish();
  static const int kFINISHFieldNumber = 5;
  const ::schedulerMessages::Response_finish& finish() const;
  ::schedulerMessages::Response_finish* mutable_finish();
  ::schedulerMessages::Response_finish* release_finish();
  void set_allocated_finish(::schedulerMessages::Response_finish* finish);

  // optional .schedulerMessages.Response_cancel CANCEL = 6;
  bool has_cancel() const;
  void clear_cancel();
  static const int kCANCELFieldNumber = 6;
  const ::schedulerMessages::Response_cancel& cancel() const;
  ::schedulerMessages::Response_cancel* mutable_cancel();
  ::schedulerMessages::Response_cancel* release_cancel();
  void set_allocated_cancel(::schedulerMessages::Response_cancel* cancel);

  // optional .schedulerMessages.Response_add_dependency ADD_DEPENDENCY = 7;
  bool has_add_dependency() const;
  void clear_add_dependency();
  static const int kADDDEPENDENCYFieldNumber = 7;
  const ::schedulerMessages::Response_add_dependency& add_dependency() const;
  ::schedulerMessages::Response_add_dependency* mutable_add_dependency();
  ::schedulerMessages::Response_add_dependency* release_add_dependency();
  void set_allocated_add_dependency(::schedulerMessages::Response_add_dependency* add_dependency);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:schedulerMessages.Response)
 private:
  inline void set_has_assign();
  inline void set_has_queue();
  inline void set_has_receive();
  inline void set_has_requeue();
  inline void set_has_finish();
  inline void set_has_cancel();
  inline void set_has_add_dependency();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union TypeUnion {
    TypeUnion() {}
    ::schedulerMessages::Response_assign* assign_;
    ::schedulerMessages::Response_queue* queue_;
    ::schedulerMessages::Response_receive* receive_;
    ::schedulerMessages::Response_requeue* requeue_;
    ::schedulerMessages::Response_finish* finish_;
    ::schedulerMessages::Response_cancel* cancel_;
    ::schedulerMessages::Response_add_dependency* add_dependency_;
  } type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Request_assign : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Request_assign) */ {
 public:
  Request_assign();
  virtual ~Request_assign();

  Request_assign(const Request_assign& from);

  inline Request_assign& operator=(const Request_assign& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_assign& default_instance();

  void Swap(Request_assign* other);

  // implements Message ----------------------------------------------

  inline Request_assign* New() const { return New(NULL); }

  Request_assign* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_assign& from);
  void MergeFrom(const Request_assign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_assign* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 count = 1;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // optional string job = 2;
  void clear_job();
  static const int kJobFieldNumber = 2;
  const ::std::string& job() const;
  void set_job(const ::std::string& value);
  void set_job(const char* value);
  void set_job(const char* value, size_t size);
  ::std::string* mutable_job();
  ::std::string* release_job();
  void set_allocated_job(::std::string* job);

  // @@protoc_insertion_point(class_scope:schedulerMessages.Request_assign)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr job_;
  ::google::protobuf::int32 count_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Request_assign* default_instance_;
};
// -------------------------------------------------------------------

class Request_queue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Request_queue) */ {
 public:
  Request_queue();
  virtual ~Request_queue();

  Request_queue(const Request_queue& from);

  inline Request_queue& operator=(const Request_queue& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_queue& default_instance();

  void Swap(Request_queue* other);

  // implements Message ----------------------------------------------

  inline Request_queue* New() const { return New(NULL); }

  Request_queue* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_queue& from);
  void MergeFrom(const Request_queue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_queue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional string input_bundle = 2;
  void clear_input_bundle();
  static const int kInputBundleFieldNumber = 2;
  const ::std::string& input_bundle() const;
  void set_input_bundle(const ::std::string& value);
  void set_input_bundle(const char* value);
  void set_input_bundle(const char* value, size_t size);
  ::std::string* mutable_input_bundle();
  ::std::string* release_input_bundle();
  void set_allocated_input_bundle(::std::string* input_bundle);

  // optional int32 task_queued_from = 3;
  void clear_task_queued_from();
  static const int kTaskQueuedFromFieldNumber = 3;
  ::google::protobuf::int32 task_queued_from() const;
  void set_task_queued_from(::google::protobuf::int32 value);

  // optional string job = 4;
  void clear_job();
  static const int kJobFieldNumber = 4;
  const ::std::string& job() const;
  void set_job(const ::std::string& value);
  void set_job(const char* value);
  void set_job(const char* value, size_t size);
  ::std::string* mutable_job();
  ::std::string* release_job();
  void set_allocated_job(::std::string* job);

  // @@protoc_insertion_point(class_scope:schedulerMessages.Request_queue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr input_bundle_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 task_queued_from_;
  ::google::protobuf::internal::ArenaStringPtr job_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Request_queue* default_instance_;
};
// -------------------------------------------------------------------

class Request_receive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Request_receive) */ {
 public:
  Request_receive();
  virtual ~Request_receive();

  Request_receive(const Request_receive& from);

  inline Request_receive& operator=(const Request_receive& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_receive& default_instance();

  void Swap(Request_receive* other);

  // implements Message ----------------------------------------------

  inline Request_receive* New() const { return New(NULL); }

  Request_receive* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_receive& from);
  void MergeFrom(const Request_receive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_receive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string instance_name = 1;
  void clear_instance_name();
  static const int kInstanceNameFieldNumber = 1;
  const ::std::string& instance_name() const;
  void set_instance_name(const ::std::string& value);
  void set_instance_name(const char* value);
  void set_instance_name(const char* value, size_t size);
  ::std::string* mutable_instance_name();
  ::std::string* release_instance_name();
  void set_allocated_instance_name(::std::string* instance_name);

  // @@protoc_insertion_point(class_scope:schedulerMessages.Request_receive)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr instance_name_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Request_receive* default_instance_;
};
// -------------------------------------------------------------------

class Request_requeue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Request_requeue) */ {
 public:
  Request_requeue();
  virtual ~Request_requeue();

  Request_requeue(const Request_requeue& from);

  inline Request_requeue& operator=(const Request_requeue& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_requeue& default_instance();

  void Swap(Request_requeue* other);

  // implements Message ----------------------------------------------

  inline Request_requeue* New() const { return New(NULL); }

  Request_requeue* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_requeue& from);
  void MergeFrom(const Request_requeue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_requeue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional string job = 2;
  void clear_job();
  static const int kJobFieldNumber = 2;
  const ::std::string& job() const;
  void set_job(const ::std::string& value);
  void set_job(const char* value);
  void set_job(const char* value, size_t size);
  ::std::string* mutable_job();
  ::std::string* release_job();
  void set_allocated_job(::std::string* job);

  // @@protoc_insertion_point(class_scope:schedulerMessages.Request_requeue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr job_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Request_requeue* default_instance_;
};
// -------------------------------------------------------------------

class Request_finish : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Request_finish) */ {
 public:
  Request_finish();
  virtual ~Request_finish();

  Request_finish(const Request_finish& from);

  inline Request_finish& operator=(const Request_finish& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_finish& default_instance();

  void Swap(Request_finish* other);

  // implements Message ----------------------------------------------

  inline Request_finish* New() const { return New(NULL); }

  Request_finish* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_finish& from);
  void MergeFrom(const Request_finish& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_finish* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional string job = 2;
  void clear_job();
  static const int kJobFieldNumber = 2;
  const ::std::string& job() const;
  void set_job(const ::std::string& value);
  void set_job(const char* value);
  void set_job(const char* value, size_t size);
  ::std::string* mutable_job();
  ::std::string* release_job();
  void set_allocated_job(::std::string* job);

  // @@protoc_insertion_point(class_scope:schedulerMessages.Request_finish)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr job_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Request_finish* default_instance_;
};
// -------------------------------------------------------------------

class Request_cancel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Request_cancel) */ {
 public:
  Request_cancel();
  virtual ~Request_cancel();

  Request_cancel(const Request_cancel& from);

  inline Request_cancel& operator=(const Request_cancel& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_cancel& default_instance();

  void Swap(Request_cancel* other);

  // implements Message ----------------------------------------------

  inline Request_cancel* New() const { return New(NULL); }

  Request_cancel* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_cancel& from);
  void MergeFrom(const Request_cancel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_cancel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional string job = 2;
  void clear_job();
  static const int kJobFieldNumber = 2;
  const ::std::string& job() const;
  void set_job(const ::std::string& value);
  void set_job(const char* value);
  void set_job(const char* value, size_t size);
  ::std::string* mutable_job();
  ::std::string* release_job();
  void set_allocated_job(::std::string* job);

  // @@protoc_insertion_point(class_scope:schedulerMessages.Request_cancel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr job_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Request_cancel* default_instance_;
};
// -------------------------------------------------------------------

class Request_add_dependency : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Request_add_dependency) */ {
 public:
  Request_add_dependency();
  virtual ~Request_add_dependency();

  Request_add_dependency(const Request_add_dependency& from);

  inline Request_add_dependency& operator=(const Request_add_dependency& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request_add_dependency& default_instance();

  void Swap(Request_add_dependency* other);

  // implements Message ----------------------------------------------

  inline Request_add_dependency* New() const { return New(NULL); }

  Request_add_dependency* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request_add_dependency& from);
  void MergeFrom(const Request_add_dependency& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Request_add_dependency* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 parent_id = 1;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 1;
  ::google::protobuf::int32 parent_id() const;
  void set_parent_id(::google::protobuf::int32 value);

  // optional int32 child_id = 2;
  void clear_child_id();
  static const int kChildIdFieldNumber = 2;
  ::google::protobuf::int32 child_id() const;
  void set_child_id(::google::protobuf::int32 value);

  // optional string job = 3;
  void clear_job();
  static const int kJobFieldNumber = 3;
  const ::std::string& job() const;
  void set_job(const ::std::string& value);
  void set_job(const char* value);
  void set_job(const char* value, size_t size);
  ::std::string* mutable_job();
  ::std::string* release_job();
  void set_allocated_job(::std::string* job);

  // @@protoc_insertion_point(class_scope:schedulerMessages.Request_add_dependency)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 parent_id_;
  ::google::protobuf::int32 child_id_;
  ::google::protobuf::internal::ArenaStringPtr job_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Request_add_dependency* default_instance_;
};
// -------------------------------------------------------------------

class Response_assign : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Response_assign) */ {
 public:
  Response_assign();
  virtual ~Response_assign();

  Response_assign(const Response_assign& from);

  inline Response_assign& operator=(const Response_assign& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_assign& default_instance();

  void Swap(Response_assign* other);

  // implements Message ----------------------------------------------

  inline Response_assign* New() const { return New(NULL); }

  Response_assign* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_assign& from);
  void MergeFrom(const Response_assign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_assign* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool multiple = 1;
  void clear_multiple();
  static const int kMultipleFieldNumber = 1;
  bool multiple() const;
  void set_multiple(bool value);

  // optional int32 id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // repeated int32 ids = 3;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 3;
  ::google::protobuf::int32 ids(int index) const;
  void set_ids(int index, ::google::protobuf::int32 value);
  void add_ids(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ids();

  // @@protoc_insertion_point(class_scope:schedulerMessages.Response_assign)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool multiple_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ids_;
  mutable int _ids_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Response_assign* default_instance_;
};
// -------------------------------------------------------------------

class Response_queue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Response_queue) */ {
 public:
  Response_queue();
  virtual ~Response_queue();

  Response_queue(const Response_queue& from);

  inline Response_queue& operator=(const Response_queue& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_queue& default_instance();

  void Swap(Response_queue* other);

  // implements Message ----------------------------------------------

  inline Response_queue* New() const { return New(NULL); }

  Response_queue* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_queue& from);
  void MergeFrom(const Response_queue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_queue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:schedulerMessages.Response_queue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Response_queue* default_instance_;
};
// -------------------------------------------------------------------

class Response_receive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Response_receive) */ {
 public:
  Response_receive();
  virtual ~Response_receive();

  Response_receive(const Response_receive& from);

  inline Response_receive& operator=(const Response_receive& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_receive& default_instance();

  void Swap(Response_receive* other);

  // implements Message ----------------------------------------------

  inline Response_receive* New() const { return New(NULL); }

  Response_receive* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_receive& from);
  void MergeFrom(const Response_receive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_receive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string input_bundle = 1;
  void clear_input_bundle();
  static const int kInputBundleFieldNumber = 1;
  const ::std::string& input_bundle() const;
  void set_input_bundle(const ::std::string& value);
  void set_input_bundle(const char* value);
  void set_input_bundle(const char* value, size_t size);
  ::std::string* mutable_input_bundle();
  ::std::string* release_input_bundle();
  void set_allocated_input_bundle(::std::string* input_bundle);

  // @@protoc_insertion_point(class_scope:schedulerMessages.Response_receive)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr input_bundle_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Response_receive* default_instance_;
};
// -------------------------------------------------------------------

class Response_requeue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Response_requeue) */ {
 public:
  Response_requeue();
  virtual ~Response_requeue();

  Response_requeue(const Response_requeue& from);

  inline Response_requeue& operator=(const Response_requeue& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_requeue& default_instance();

  void Swap(Response_requeue* other);

  // implements Message ----------------------------------------------

  inline Response_requeue* New() const { return New(NULL); }

  Response_requeue* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_requeue& from);
  void MergeFrom(const Response_requeue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_requeue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool requeue_failed = 1;
  void clear_requeue_failed();
  static const int kRequeueFailedFieldNumber = 1;
  bool requeue_failed() const;
  void set_requeue_failed(bool value);

  // @@protoc_insertion_point(class_scope:schedulerMessages.Response_requeue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool requeue_failed_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Response_requeue* default_instance_;
};
// -------------------------------------------------------------------

class Response_finish : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Response_finish) */ {
 public:
  Response_finish();
  virtual ~Response_finish();

  Response_finish(const Response_finish& from);

  inline Response_finish& operator=(const Response_finish& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_finish& default_instance();

  void Swap(Response_finish* other);

  // implements Message ----------------------------------------------

  inline Response_finish* New() const { return New(NULL); }

  Response_finish* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_finish& from);
  void MergeFrom(const Response_finish& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_finish* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:schedulerMessages.Response_finish)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Response_finish* default_instance_;
};
// -------------------------------------------------------------------

class Response_cancel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Response_cancel) */ {
 public:
  Response_cancel();
  virtual ~Response_cancel();

  Response_cancel(const Response_cancel& from);

  inline Response_cancel& operator=(const Response_cancel& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_cancel& default_instance();

  void Swap(Response_cancel* other);

  // implements Message ----------------------------------------------

  inline Response_cancel* New() const { return New(NULL); }

  Response_cancel* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_cancel& from);
  void MergeFrom(const Response_cancel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_cancel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:schedulerMessages.Response_cancel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Response_cancel* default_instance_;
};
// -------------------------------------------------------------------

class Response_add_dependency : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:schedulerMessages.Response_add_dependency) */ {
 public:
  Response_add_dependency();
  virtual ~Response_add_dependency();

  Response_add_dependency(const Response_add_dependency& from);

  inline Response_add_dependency& operator=(const Response_add_dependency& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response_add_dependency& default_instance();

  void Swap(Response_add_dependency* other);

  // implements Message ----------------------------------------------

  inline Response_add_dependency* New() const { return New(NULL); }

  Response_add_dependency* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response_add_dependency& from);
  void MergeFrom(const Response_add_dependency& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response_add_dependency* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:schedulerMessages.Response_add_dependency)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msg_2eproto();
  friend void protobuf_AssignDesc_msg_2eproto();
  friend void protobuf_ShutdownFile_msg_2eproto();

  void InitAsDefaultInstance();
  static Response_add_dependency* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Msg

// optional .schedulerMessages.Request REQUEST = 1;
inline bool Msg::has_request() const {
  return type_case() == kREQUEST;
}
inline void Msg::set_has_request() {
  _oneof_case_[0] = kREQUEST;
}
inline void Msg::clear_request() {
  if (has_request()) {
    delete type_.request_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Request& Msg::request() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Msg.REQUEST)
  return has_request()
      ? *type_.request_
      : ::schedulerMessages::Request::default_instance();
}
inline ::schedulerMessages::Request* Msg::mutable_request() {
  if (!has_request()) {
    clear_type();
    set_has_request();
    type_.request_ = new ::schedulerMessages::Request;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Msg.REQUEST)
  return type_.request_;
}
inline ::schedulerMessages::Request* Msg::release_request() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Msg.REQUEST)
  if (has_request()) {
    clear_has_type();
    ::schedulerMessages::Request* temp = type_.request_;
    type_.request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Msg::set_allocated_request(::schedulerMessages::Request* request) {
  clear_type();
  if (request) {
    set_has_request();
    type_.request_ = request;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Msg.REQUEST)
}

// optional .schedulerMessages.Response RESPONSE = 2;
inline bool Msg::has_response() const {
  return type_case() == kRESPONSE;
}
inline void Msg::set_has_response() {
  _oneof_case_[0] = kRESPONSE;
}
inline void Msg::clear_response() {
  if (has_response()) {
    delete type_.response_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Response& Msg::response() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Msg.RESPONSE)
  return has_response()
      ? *type_.response_
      : ::schedulerMessages::Response::default_instance();
}
inline ::schedulerMessages::Response* Msg::mutable_response() {
  if (!has_response()) {
    clear_type();
    set_has_response();
    type_.response_ = new ::schedulerMessages::Response;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Msg.RESPONSE)
  return type_.response_;
}
inline ::schedulerMessages::Response* Msg::release_response() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Msg.RESPONSE)
  if (has_response()) {
    clear_has_type();
    ::schedulerMessages::Response* temp = type_.response_;
    type_.response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Msg::set_allocated_response(::schedulerMessages::Response* response) {
  clear_type();
  if (response) {
    set_has_response();
    type_.response_ = response;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Msg.RESPONSE)
}

inline bool Msg::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Msg::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Msg::TypeCase Msg::type_case() const {
  return Msg::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Request

// optional .schedulerMessages.Request_assign ASSIGN = 1;
inline bool Request::has_assign() const {
  return type_case() == kASSIGN;
}
inline void Request::set_has_assign() {
  _oneof_case_[0] = kASSIGN;
}
inline void Request::clear_assign() {
  if (has_assign()) {
    delete type_.assign_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Request_assign& Request::assign() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request.ASSIGN)
  return has_assign()
      ? *type_.assign_
      : ::schedulerMessages::Request_assign::default_instance();
}
inline ::schedulerMessages::Request_assign* Request::mutable_assign() {
  if (!has_assign()) {
    clear_type();
    set_has_assign();
    type_.assign_ = new ::schedulerMessages::Request_assign;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request.ASSIGN)
  return type_.assign_;
}
inline ::schedulerMessages::Request_assign* Request::release_assign() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request.ASSIGN)
  if (has_assign()) {
    clear_has_type();
    ::schedulerMessages::Request_assign* temp = type_.assign_;
    type_.assign_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_assign(::schedulerMessages::Request_assign* assign) {
  clear_type();
  if (assign) {
    set_has_assign();
    type_.assign_ = assign;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request.ASSIGN)
}

// optional .schedulerMessages.Request_queue QUEUE = 2;
inline bool Request::has_queue() const {
  return type_case() == kQUEUE;
}
inline void Request::set_has_queue() {
  _oneof_case_[0] = kQUEUE;
}
inline void Request::clear_queue() {
  if (has_queue()) {
    delete type_.queue_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Request_queue& Request::queue() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request.QUEUE)
  return has_queue()
      ? *type_.queue_
      : ::schedulerMessages::Request_queue::default_instance();
}
inline ::schedulerMessages::Request_queue* Request::mutable_queue() {
  if (!has_queue()) {
    clear_type();
    set_has_queue();
    type_.queue_ = new ::schedulerMessages::Request_queue;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request.QUEUE)
  return type_.queue_;
}
inline ::schedulerMessages::Request_queue* Request::release_queue() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request.QUEUE)
  if (has_queue()) {
    clear_has_type();
    ::schedulerMessages::Request_queue* temp = type_.queue_;
    type_.queue_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_queue(::schedulerMessages::Request_queue* queue) {
  clear_type();
  if (queue) {
    set_has_queue();
    type_.queue_ = queue;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request.QUEUE)
}

// optional .schedulerMessages.Request_receive RECEIVE = 3;
inline bool Request::has_receive() const {
  return type_case() == kRECEIVE;
}
inline void Request::set_has_receive() {
  _oneof_case_[0] = kRECEIVE;
}
inline void Request::clear_receive() {
  if (has_receive()) {
    delete type_.receive_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Request_receive& Request::receive() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request.RECEIVE)
  return has_receive()
      ? *type_.receive_
      : ::schedulerMessages::Request_receive::default_instance();
}
inline ::schedulerMessages::Request_receive* Request::mutable_receive() {
  if (!has_receive()) {
    clear_type();
    set_has_receive();
    type_.receive_ = new ::schedulerMessages::Request_receive;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request.RECEIVE)
  return type_.receive_;
}
inline ::schedulerMessages::Request_receive* Request::release_receive() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request.RECEIVE)
  if (has_receive()) {
    clear_has_type();
    ::schedulerMessages::Request_receive* temp = type_.receive_;
    type_.receive_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_receive(::schedulerMessages::Request_receive* receive) {
  clear_type();
  if (receive) {
    set_has_receive();
    type_.receive_ = receive;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request.RECEIVE)
}

// optional .schedulerMessages.Request_requeue REQUEUE = 4;
inline bool Request::has_requeue() const {
  return type_case() == kREQUEUE;
}
inline void Request::set_has_requeue() {
  _oneof_case_[0] = kREQUEUE;
}
inline void Request::clear_requeue() {
  if (has_requeue()) {
    delete type_.requeue_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Request_requeue& Request::requeue() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request.REQUEUE)
  return has_requeue()
      ? *type_.requeue_
      : ::schedulerMessages::Request_requeue::default_instance();
}
inline ::schedulerMessages::Request_requeue* Request::mutable_requeue() {
  if (!has_requeue()) {
    clear_type();
    set_has_requeue();
    type_.requeue_ = new ::schedulerMessages::Request_requeue;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request.REQUEUE)
  return type_.requeue_;
}
inline ::schedulerMessages::Request_requeue* Request::release_requeue() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request.REQUEUE)
  if (has_requeue()) {
    clear_has_type();
    ::schedulerMessages::Request_requeue* temp = type_.requeue_;
    type_.requeue_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_requeue(::schedulerMessages::Request_requeue* requeue) {
  clear_type();
  if (requeue) {
    set_has_requeue();
    type_.requeue_ = requeue;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request.REQUEUE)
}

// optional .schedulerMessages.Request_finish FINISH = 5;
inline bool Request::has_finish() const {
  return type_case() == kFINISH;
}
inline void Request::set_has_finish() {
  _oneof_case_[0] = kFINISH;
}
inline void Request::clear_finish() {
  if (has_finish()) {
    delete type_.finish_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Request_finish& Request::finish() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request.FINISH)
  return has_finish()
      ? *type_.finish_
      : ::schedulerMessages::Request_finish::default_instance();
}
inline ::schedulerMessages::Request_finish* Request::mutable_finish() {
  if (!has_finish()) {
    clear_type();
    set_has_finish();
    type_.finish_ = new ::schedulerMessages::Request_finish;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request.FINISH)
  return type_.finish_;
}
inline ::schedulerMessages::Request_finish* Request::release_finish() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request.FINISH)
  if (has_finish()) {
    clear_has_type();
    ::schedulerMessages::Request_finish* temp = type_.finish_;
    type_.finish_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_finish(::schedulerMessages::Request_finish* finish) {
  clear_type();
  if (finish) {
    set_has_finish();
    type_.finish_ = finish;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request.FINISH)
}

// optional .schedulerMessages.Request_cancel CANCEL = 6;
inline bool Request::has_cancel() const {
  return type_case() == kCANCEL;
}
inline void Request::set_has_cancel() {
  _oneof_case_[0] = kCANCEL;
}
inline void Request::clear_cancel() {
  if (has_cancel()) {
    delete type_.cancel_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Request_cancel& Request::cancel() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request.CANCEL)
  return has_cancel()
      ? *type_.cancel_
      : ::schedulerMessages::Request_cancel::default_instance();
}
inline ::schedulerMessages::Request_cancel* Request::mutable_cancel() {
  if (!has_cancel()) {
    clear_type();
    set_has_cancel();
    type_.cancel_ = new ::schedulerMessages::Request_cancel;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request.CANCEL)
  return type_.cancel_;
}
inline ::schedulerMessages::Request_cancel* Request::release_cancel() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request.CANCEL)
  if (has_cancel()) {
    clear_has_type();
    ::schedulerMessages::Request_cancel* temp = type_.cancel_;
    type_.cancel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_cancel(::schedulerMessages::Request_cancel* cancel) {
  clear_type();
  if (cancel) {
    set_has_cancel();
    type_.cancel_ = cancel;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request.CANCEL)
}

// optional .schedulerMessages.Request_add_dependency ADD_DEPENDENCY = 7;
inline bool Request::has_add_dependency() const {
  return type_case() == kADDDEPENDENCY;
}
inline void Request::set_has_add_dependency() {
  _oneof_case_[0] = kADDDEPENDENCY;
}
inline void Request::clear_add_dependency() {
  if (has_add_dependency()) {
    delete type_.add_dependency_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Request_add_dependency& Request::add_dependency() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request.ADD_DEPENDENCY)
  return has_add_dependency()
      ? *type_.add_dependency_
      : ::schedulerMessages::Request_add_dependency::default_instance();
}
inline ::schedulerMessages::Request_add_dependency* Request::mutable_add_dependency() {
  if (!has_add_dependency()) {
    clear_type();
    set_has_add_dependency();
    type_.add_dependency_ = new ::schedulerMessages::Request_add_dependency;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request.ADD_DEPENDENCY)
  return type_.add_dependency_;
}
inline ::schedulerMessages::Request_add_dependency* Request::release_add_dependency() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request.ADD_DEPENDENCY)
  if (has_add_dependency()) {
    clear_has_type();
    ::schedulerMessages::Request_add_dependency* temp = type_.add_dependency_;
    type_.add_dependency_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_add_dependency(::schedulerMessages::Request_add_dependency* add_dependency) {
  clear_type();
  if (add_dependency) {
    set_has_add_dependency();
    type_.add_dependency_ = add_dependency;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request.ADD_DEPENDENCY)
}

inline bool Request::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Request::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Request::TypeCase Request::type_case() const {
  return Request::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// optional .schedulerMessages.Response_assign ASSIGN = 1;
inline bool Response::has_assign() const {
  return type_case() == kASSIGN;
}
inline void Response::set_has_assign() {
  _oneof_case_[0] = kASSIGN;
}
inline void Response::clear_assign() {
  if (has_assign()) {
    delete type_.assign_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Response_assign& Response::assign() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Response.ASSIGN)
  return has_assign()
      ? *type_.assign_
      : ::schedulerMessages::Response_assign::default_instance();
}
inline ::schedulerMessages::Response_assign* Response::mutable_assign() {
  if (!has_assign()) {
    clear_type();
    set_has_assign();
    type_.assign_ = new ::schedulerMessages::Response_assign;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Response.ASSIGN)
  return type_.assign_;
}
inline ::schedulerMessages::Response_assign* Response::release_assign() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Response.ASSIGN)
  if (has_assign()) {
    clear_has_type();
    ::schedulerMessages::Response_assign* temp = type_.assign_;
    type_.assign_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_assign(::schedulerMessages::Response_assign* assign) {
  clear_type();
  if (assign) {
    set_has_assign();
    type_.assign_ = assign;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Response.ASSIGN)
}

// optional .schedulerMessages.Response_queue QUEUE = 2;
inline bool Response::has_queue() const {
  return type_case() == kQUEUE;
}
inline void Response::set_has_queue() {
  _oneof_case_[0] = kQUEUE;
}
inline void Response::clear_queue() {
  if (has_queue()) {
    delete type_.queue_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Response_queue& Response::queue() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Response.QUEUE)
  return has_queue()
      ? *type_.queue_
      : ::schedulerMessages::Response_queue::default_instance();
}
inline ::schedulerMessages::Response_queue* Response::mutable_queue() {
  if (!has_queue()) {
    clear_type();
    set_has_queue();
    type_.queue_ = new ::schedulerMessages::Response_queue;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Response.QUEUE)
  return type_.queue_;
}
inline ::schedulerMessages::Response_queue* Response::release_queue() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Response.QUEUE)
  if (has_queue()) {
    clear_has_type();
    ::schedulerMessages::Response_queue* temp = type_.queue_;
    type_.queue_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_queue(::schedulerMessages::Response_queue* queue) {
  clear_type();
  if (queue) {
    set_has_queue();
    type_.queue_ = queue;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Response.QUEUE)
}

// optional .schedulerMessages.Response_receive RECEIVE = 3;
inline bool Response::has_receive() const {
  return type_case() == kRECEIVE;
}
inline void Response::set_has_receive() {
  _oneof_case_[0] = kRECEIVE;
}
inline void Response::clear_receive() {
  if (has_receive()) {
    delete type_.receive_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Response_receive& Response::receive() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Response.RECEIVE)
  return has_receive()
      ? *type_.receive_
      : ::schedulerMessages::Response_receive::default_instance();
}
inline ::schedulerMessages::Response_receive* Response::mutable_receive() {
  if (!has_receive()) {
    clear_type();
    set_has_receive();
    type_.receive_ = new ::schedulerMessages::Response_receive;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Response.RECEIVE)
  return type_.receive_;
}
inline ::schedulerMessages::Response_receive* Response::release_receive() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Response.RECEIVE)
  if (has_receive()) {
    clear_has_type();
    ::schedulerMessages::Response_receive* temp = type_.receive_;
    type_.receive_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_receive(::schedulerMessages::Response_receive* receive) {
  clear_type();
  if (receive) {
    set_has_receive();
    type_.receive_ = receive;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Response.RECEIVE)
}

// optional .schedulerMessages.Response_requeue REQUEUE = 4;
inline bool Response::has_requeue() const {
  return type_case() == kREQUEUE;
}
inline void Response::set_has_requeue() {
  _oneof_case_[0] = kREQUEUE;
}
inline void Response::clear_requeue() {
  if (has_requeue()) {
    delete type_.requeue_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Response_requeue& Response::requeue() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Response.REQUEUE)
  return has_requeue()
      ? *type_.requeue_
      : ::schedulerMessages::Response_requeue::default_instance();
}
inline ::schedulerMessages::Response_requeue* Response::mutable_requeue() {
  if (!has_requeue()) {
    clear_type();
    set_has_requeue();
    type_.requeue_ = new ::schedulerMessages::Response_requeue;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Response.REQUEUE)
  return type_.requeue_;
}
inline ::schedulerMessages::Response_requeue* Response::release_requeue() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Response.REQUEUE)
  if (has_requeue()) {
    clear_has_type();
    ::schedulerMessages::Response_requeue* temp = type_.requeue_;
    type_.requeue_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_requeue(::schedulerMessages::Response_requeue* requeue) {
  clear_type();
  if (requeue) {
    set_has_requeue();
    type_.requeue_ = requeue;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Response.REQUEUE)
}

// optional .schedulerMessages.Response_finish FINISH = 5;
inline bool Response::has_finish() const {
  return type_case() == kFINISH;
}
inline void Response::set_has_finish() {
  _oneof_case_[0] = kFINISH;
}
inline void Response::clear_finish() {
  if (has_finish()) {
    delete type_.finish_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Response_finish& Response::finish() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Response.FINISH)
  return has_finish()
      ? *type_.finish_
      : ::schedulerMessages::Response_finish::default_instance();
}
inline ::schedulerMessages::Response_finish* Response::mutable_finish() {
  if (!has_finish()) {
    clear_type();
    set_has_finish();
    type_.finish_ = new ::schedulerMessages::Response_finish;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Response.FINISH)
  return type_.finish_;
}
inline ::schedulerMessages::Response_finish* Response::release_finish() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Response.FINISH)
  if (has_finish()) {
    clear_has_type();
    ::schedulerMessages::Response_finish* temp = type_.finish_;
    type_.finish_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_finish(::schedulerMessages::Response_finish* finish) {
  clear_type();
  if (finish) {
    set_has_finish();
    type_.finish_ = finish;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Response.FINISH)
}

// optional .schedulerMessages.Response_cancel CANCEL = 6;
inline bool Response::has_cancel() const {
  return type_case() == kCANCEL;
}
inline void Response::set_has_cancel() {
  _oneof_case_[0] = kCANCEL;
}
inline void Response::clear_cancel() {
  if (has_cancel()) {
    delete type_.cancel_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Response_cancel& Response::cancel() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Response.CANCEL)
  return has_cancel()
      ? *type_.cancel_
      : ::schedulerMessages::Response_cancel::default_instance();
}
inline ::schedulerMessages::Response_cancel* Response::mutable_cancel() {
  if (!has_cancel()) {
    clear_type();
    set_has_cancel();
    type_.cancel_ = new ::schedulerMessages::Response_cancel;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Response.CANCEL)
  return type_.cancel_;
}
inline ::schedulerMessages::Response_cancel* Response::release_cancel() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Response.CANCEL)
  if (has_cancel()) {
    clear_has_type();
    ::schedulerMessages::Response_cancel* temp = type_.cancel_;
    type_.cancel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_cancel(::schedulerMessages::Response_cancel* cancel) {
  clear_type();
  if (cancel) {
    set_has_cancel();
    type_.cancel_ = cancel;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Response.CANCEL)
}

// optional .schedulerMessages.Response_add_dependency ADD_DEPENDENCY = 7;
inline bool Response::has_add_dependency() const {
  return type_case() == kADDDEPENDENCY;
}
inline void Response::set_has_add_dependency() {
  _oneof_case_[0] = kADDDEPENDENCY;
}
inline void Response::clear_add_dependency() {
  if (has_add_dependency()) {
    delete type_.add_dependency_;
    clear_has_type();
  }
}
inline  const ::schedulerMessages::Response_add_dependency& Response::add_dependency() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Response.ADD_DEPENDENCY)
  return has_add_dependency()
      ? *type_.add_dependency_
      : ::schedulerMessages::Response_add_dependency::default_instance();
}
inline ::schedulerMessages::Response_add_dependency* Response::mutable_add_dependency() {
  if (!has_add_dependency()) {
    clear_type();
    set_has_add_dependency();
    type_.add_dependency_ = new ::schedulerMessages::Response_add_dependency;
  }
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Response.ADD_DEPENDENCY)
  return type_.add_dependency_;
}
inline ::schedulerMessages::Response_add_dependency* Response::release_add_dependency() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Response.ADD_DEPENDENCY)
  if (has_add_dependency()) {
    clear_has_type();
    ::schedulerMessages::Response_add_dependency* temp = type_.add_dependency_;
    type_.add_dependency_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_add_dependency(::schedulerMessages::Response_add_dependency* add_dependency) {
  clear_type();
  if (add_dependency) {
    set_has_add_dependency();
    type_.add_dependency_ = add_dependency;
  }
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Response.ADD_DEPENDENCY)
}

inline bool Response::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Response::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Response::TypeCase Response::type_case() const {
  return Response::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Request_assign

// optional int32 count = 1;
inline void Request_assign::clear_count() {
  count_ = 0;
}
inline ::google::protobuf::int32 Request_assign::count() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_assign.count)
  return count_;
}
inline void Request_assign::set_count(::google::protobuf::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_assign.count)
}

// optional string job = 2;
inline void Request_assign::clear_job() {
  job_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Request_assign::job() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_assign.job)
  return job_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_assign::set_job(const ::std::string& value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_assign.job)
}
inline void Request_assign::set_job(const char* value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerMessages.Request_assign.job)
}
inline void Request_assign::set_job(const char* value, size_t size) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerMessages.Request_assign.job)
}
inline ::std::string* Request_assign::mutable_job() {
  
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request_assign.job)
  return job_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_assign::release_job() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request_assign.job)
  
  return job_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_assign::set_allocated_job(::std::string* job) {
  if (job != NULL) {
    
  } else {
    
  }
  job_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), job);
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request_assign.job)
}

// -------------------------------------------------------------------

// Request_queue

// optional int32 id = 1;
inline void Request_queue::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Request_queue::id() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_queue.id)
  return id_;
}
inline void Request_queue::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_queue.id)
}

// optional string input_bundle = 2;
inline void Request_queue::clear_input_bundle() {
  input_bundle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Request_queue::input_bundle() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_queue.input_bundle)
  return input_bundle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_queue::set_input_bundle(const ::std::string& value) {
  
  input_bundle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_queue.input_bundle)
}
inline void Request_queue::set_input_bundle(const char* value) {
  
  input_bundle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerMessages.Request_queue.input_bundle)
}
inline void Request_queue::set_input_bundle(const char* value, size_t size) {
  
  input_bundle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerMessages.Request_queue.input_bundle)
}
inline ::std::string* Request_queue::mutable_input_bundle() {
  
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request_queue.input_bundle)
  return input_bundle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_queue::release_input_bundle() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request_queue.input_bundle)
  
  return input_bundle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_queue::set_allocated_input_bundle(::std::string* input_bundle) {
  if (input_bundle != NULL) {
    
  } else {
    
  }
  input_bundle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_bundle);
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request_queue.input_bundle)
}

// optional int32 task_queued_from = 3;
inline void Request_queue::clear_task_queued_from() {
  task_queued_from_ = 0;
}
inline ::google::protobuf::int32 Request_queue::task_queued_from() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_queue.task_queued_from)
  return task_queued_from_;
}
inline void Request_queue::set_task_queued_from(::google::protobuf::int32 value) {
  
  task_queued_from_ = value;
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_queue.task_queued_from)
}

// optional string job = 4;
inline void Request_queue::clear_job() {
  job_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Request_queue::job() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_queue.job)
  return job_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_queue::set_job(const ::std::string& value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_queue.job)
}
inline void Request_queue::set_job(const char* value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerMessages.Request_queue.job)
}
inline void Request_queue::set_job(const char* value, size_t size) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerMessages.Request_queue.job)
}
inline ::std::string* Request_queue::mutable_job() {
  
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request_queue.job)
  return job_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_queue::release_job() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request_queue.job)
  
  return job_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_queue::set_allocated_job(::std::string* job) {
  if (job != NULL) {
    
  } else {
    
  }
  job_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), job);
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request_queue.job)
}

// -------------------------------------------------------------------

// Request_receive

// optional string instance_name = 1;
inline void Request_receive::clear_instance_name() {
  instance_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Request_receive::instance_name() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_receive.instance_name)
  return instance_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_receive::set_instance_name(const ::std::string& value) {
  
  instance_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_receive.instance_name)
}
inline void Request_receive::set_instance_name(const char* value) {
  
  instance_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerMessages.Request_receive.instance_name)
}
inline void Request_receive::set_instance_name(const char* value, size_t size) {
  
  instance_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerMessages.Request_receive.instance_name)
}
inline ::std::string* Request_receive::mutable_instance_name() {
  
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request_receive.instance_name)
  return instance_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_receive::release_instance_name() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request_receive.instance_name)
  
  return instance_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_receive::set_allocated_instance_name(::std::string* instance_name) {
  if (instance_name != NULL) {
    
  } else {
    
  }
  instance_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instance_name);
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request_receive.instance_name)
}

// -------------------------------------------------------------------

// Request_requeue

// optional int32 id = 1;
inline void Request_requeue::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Request_requeue::id() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_requeue.id)
  return id_;
}
inline void Request_requeue::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_requeue.id)
}

// optional string job = 2;
inline void Request_requeue::clear_job() {
  job_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Request_requeue::job() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_requeue.job)
  return job_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_requeue::set_job(const ::std::string& value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_requeue.job)
}
inline void Request_requeue::set_job(const char* value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerMessages.Request_requeue.job)
}
inline void Request_requeue::set_job(const char* value, size_t size) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerMessages.Request_requeue.job)
}
inline ::std::string* Request_requeue::mutable_job() {
  
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request_requeue.job)
  return job_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_requeue::release_job() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request_requeue.job)
  
  return job_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_requeue::set_allocated_job(::std::string* job) {
  if (job != NULL) {
    
  } else {
    
  }
  job_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), job);
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request_requeue.job)
}

// -------------------------------------------------------------------

// Request_finish

// optional int32 id = 1;
inline void Request_finish::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Request_finish::id() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_finish.id)
  return id_;
}
inline void Request_finish::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_finish.id)
}

// optional string job = 2;
inline void Request_finish::clear_job() {
  job_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Request_finish::job() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_finish.job)
  return job_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_finish::set_job(const ::std::string& value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_finish.job)
}
inline void Request_finish::set_job(const char* value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerMessages.Request_finish.job)
}
inline void Request_finish::set_job(const char* value, size_t size) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerMessages.Request_finish.job)
}
inline ::std::string* Request_finish::mutable_job() {
  
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request_finish.job)
  return job_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_finish::release_job() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request_finish.job)
  
  return job_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_finish::set_allocated_job(::std::string* job) {
  if (job != NULL) {
    
  } else {
    
  }
  job_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), job);
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request_finish.job)
}

// -------------------------------------------------------------------

// Request_cancel

// optional int32 id = 1;
inline void Request_cancel::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Request_cancel::id() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_cancel.id)
  return id_;
}
inline void Request_cancel::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_cancel.id)
}

// optional string job = 2;
inline void Request_cancel::clear_job() {
  job_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Request_cancel::job() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_cancel.job)
  return job_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_cancel::set_job(const ::std::string& value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_cancel.job)
}
inline void Request_cancel::set_job(const char* value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerMessages.Request_cancel.job)
}
inline void Request_cancel::set_job(const char* value, size_t size) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerMessages.Request_cancel.job)
}
inline ::std::string* Request_cancel::mutable_job() {
  
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request_cancel.job)
  return job_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_cancel::release_job() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request_cancel.job)
  
  return job_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_cancel::set_allocated_job(::std::string* job) {
  if (job != NULL) {
    
  } else {
    
  }
  job_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), job);
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request_cancel.job)
}

// -------------------------------------------------------------------

// Request_add_dependency

// optional int32 parent_id = 1;
inline void Request_add_dependency::clear_parent_id() {
  parent_id_ = 0;
}
inline ::google::protobuf::int32 Request_add_dependency::parent_id() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_add_dependency.parent_id)
  return parent_id_;
}
inline void Request_add_dependency::set_parent_id(::google::protobuf::int32 value) {
  
  parent_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_add_dependency.parent_id)
}

// optional int32 child_id = 2;
inline void Request_add_dependency::clear_child_id() {
  child_id_ = 0;
}
inline ::google::protobuf::int32 Request_add_dependency::child_id() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_add_dependency.child_id)
  return child_id_;
}
inline void Request_add_dependency::set_child_id(::google::protobuf::int32 value) {
  
  child_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_add_dependency.child_id)
}

// optional string job = 3;
inline void Request_add_dependency::clear_job() {
  job_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Request_add_dependency::job() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Request_add_dependency.job)
  return job_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_add_dependency::set_job(const ::std::string& value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerMessages.Request_add_dependency.job)
}
inline void Request_add_dependency::set_job(const char* value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerMessages.Request_add_dependency.job)
}
inline void Request_add_dependency::set_job(const char* value, size_t size) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerMessages.Request_add_dependency.job)
}
inline ::std::string* Request_add_dependency::mutable_job() {
  
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Request_add_dependency.job)
  return job_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request_add_dependency::release_job() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Request_add_dependency.job)
  
  return job_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request_add_dependency::set_allocated_job(::std::string* job) {
  if (job != NULL) {
    
  } else {
    
  }
  job_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), job);
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Request_add_dependency.job)
}

// -------------------------------------------------------------------

// Response_assign

// optional bool multiple = 1;
inline void Response_assign::clear_multiple() {
  multiple_ = false;
}
inline bool Response_assign::multiple() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Response_assign.multiple)
  return multiple_;
}
inline void Response_assign::set_multiple(bool value) {
  
  multiple_ = value;
  // @@protoc_insertion_point(field_set:schedulerMessages.Response_assign.multiple)
}

// optional int32 id = 2;
inline void Response_assign::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Response_assign::id() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Response_assign.id)
  return id_;
}
inline void Response_assign::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:schedulerMessages.Response_assign.id)
}

// repeated int32 ids = 3;
inline int Response_assign::ids_size() const {
  return ids_.size();
}
inline void Response_assign::clear_ids() {
  ids_.Clear();
}
inline ::google::protobuf::int32 Response_assign::ids(int index) const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Response_assign.ids)
  return ids_.Get(index);
}
inline void Response_assign::set_ids(int index, ::google::protobuf::int32 value) {
  ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:schedulerMessages.Response_assign.ids)
}
inline void Response_assign::add_ids(::google::protobuf::int32 value) {
  ids_.Add(value);
  // @@protoc_insertion_point(field_add:schedulerMessages.Response_assign.ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Response_assign::ids() const {
  // @@protoc_insertion_point(field_list:schedulerMessages.Response_assign.ids)
  return ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Response_assign::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:schedulerMessages.Response_assign.ids)
  return &ids_;
}

// -------------------------------------------------------------------

// Response_queue

// -------------------------------------------------------------------

// Response_receive

// optional string input_bundle = 1;
inline void Response_receive::clear_input_bundle() {
  input_bundle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Response_receive::input_bundle() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Response_receive.input_bundle)
  return input_bundle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_receive::set_input_bundle(const ::std::string& value) {
  
  input_bundle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerMessages.Response_receive.input_bundle)
}
inline void Response_receive::set_input_bundle(const char* value) {
  
  input_bundle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerMessages.Response_receive.input_bundle)
}
inline void Response_receive::set_input_bundle(const char* value, size_t size) {
  
  input_bundle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerMessages.Response_receive.input_bundle)
}
inline ::std::string* Response_receive::mutable_input_bundle() {
  
  // @@protoc_insertion_point(field_mutable:schedulerMessages.Response_receive.input_bundle)
  return input_bundle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response_receive::release_input_bundle() {
  // @@protoc_insertion_point(field_release:schedulerMessages.Response_receive.input_bundle)
  
  return input_bundle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response_receive::set_allocated_input_bundle(::std::string* input_bundle) {
  if (input_bundle != NULL) {
    
  } else {
    
  }
  input_bundle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_bundle);
  // @@protoc_insertion_point(field_set_allocated:schedulerMessages.Response_receive.input_bundle)
}

// -------------------------------------------------------------------

// Response_requeue

// optional bool requeue_failed = 1;
inline void Response_requeue::clear_requeue_failed() {
  requeue_failed_ = false;
}
inline bool Response_requeue::requeue_failed() const {
  // @@protoc_insertion_point(field_get:schedulerMessages.Response_requeue.requeue_failed)
  return requeue_failed_;
}
inline void Response_requeue::set_requeue_failed(bool value) {
  
  requeue_failed_ = value;
  // @@protoc_insertion_point(field_set:schedulerMessages.Response_requeue.requeue_failed)
}

// -------------------------------------------------------------------

// Response_finish

// -------------------------------------------------------------------

// Response_cancel

// -------------------------------------------------------------------

// Response_add_dependency

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace schedulerMessages

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msg_2eproto__INCLUDED
